import IFCInput from '@Components/Input/IFCInput.vue';
import { IFCSpan } from '@Components/Text/IFCSpan.vue';
import { VALID_INPUT_TYPES, VALID_STATES, STATE_MAP } from '@Components/Input/config';
import IFCButton from '@Components/Button/IFCButton.vue';
import { IFCThemeProvider } from '@Components/ThemeProvider/IFCThemeProvider.vue';

/**
 * Next line disabled because this is not production code. this is development code.
 * So importing from devDeps is fine
 */
/* eslint-disable-next-line import/no-extraneous-dependencies */
import { action } from '@storybook/addon-actions';
import { propGenerator } from '../../mixinPropGenerator.js';

export default {
  title: 'Presentational Components/Form Components/Input',
  component: IFCInput,
  parameters: {
    jest: ['IFCInput.spec.js'],
    docs: {
      description: {
        component: `This input component provides a rich interface input for text, number, email, and password inputs.
        <br/>
        **Note:** The floating label determines whether it needs to float based on focus and also the \`value\` prop.
        If you're experiencing weird issues where the label overlaps with the inputted content, you're probably
        forgetting to pass to this component what the value is. Remember, it's a presentational component, it does
        not do logic itself. If you give it no value, it will display as if there was no value.
        `,
      },
    },
  },
  argTypes: {
    ...propGenerator(IFCInput, {
      dark: 'Whether dark mode is enabled',
    }),
    dark: {
      control: {
        type: 'boolean',
        default: false,
      },
    },
    type: { control: { type: 'select', options: VALID_INPUT_TYPES } },
    state: { control: { type: 'select', options: VALID_STATES } },
    label: {
      description: 'Slot for inserting HTML content into the label',
    },
    microcopy: {
      description: `Slot for inserting HTML content as help text, or error messages, under the input.
        This defaults to autogenerated helper text based on certain prop states like minlength, maxlength, etc.`,
    },
    endcap: {
      description: 'Slot for inserting HTML content as an endcap for the input',
    },
    'front-endcap': {
      description: 'Slot for inserting HTML content as a front endcap for the input',
    },
  },
};

const EXCLUDED_KEYS = ['dark', 'label', 'microcopy', 'endcap', 'front-endcap'];

const CodeFactory = (args) => `
<IFCThemeProvider :dark="${args.dark ?? false}">
  <IFCInput
   ${Object.entries(args).filter(
    ([key]) => !EXCLUDED_KEYS.includes(key),
  ).map(([key, value]) => `${`${typeof value !== 'string' ? ':' : ''}${key}`}="${value}"\n`).join('   ')}  >
    <template v-slot:label>
      ${args.label ?? '<!-- Label Content Here -->'}
    </template>
    <template v-slot:microcopy>
      ${args.microcopy ?? '<!-- Microcopy Content Here -->'}
    </template>
    <template v-slot:endcap>
        ${args.endcap ?? '<!-- Endcap Content Here -->'}
    </template>
    <template v-slot:front-endcap>
        ${args['front-endcap'] ?? '<!-- Front Endcap Content Here -->'}
    </template>
  </IFCInput>
</IFCThemeProvider>
`;

const Template = (args, { argTypes }) => ({
  props: Object.keys(argTypes),
  components: { IFCInput, IFCThemeProvider, IFCSpan },
  data() {
    return {
      internalValue: args.value,
    };
  },
  methods: {
    onFocus: action('@focus'),
    onBlur: action('@blur'),
    onChange: action('@change'),
    onInput: action('@input'),
  },
  template: `
  <IFCThemeProvider :dark="dark">
    <IFCInput
      @focus="onFocus"
      @blur="onBlur"
      @input="onInput($event); internalValue = $event"
      @change="onChange"
      :value="internalValue"
      v-bind="$props" >
      <template #label>
        {{label}}
      </template>
      <template #microcopy>
      ${args.microcopy ?? ''}
      </template>
    </IFCInput>
  </IFCThemeProvider>
  `,
});

export const Text = Template.bind({});
Text.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: '',
};
Text.parameters = {
  docs: {
    source: {
      code: CodeFactory(Text.args),
    },
  },
};

export const Number = Template.bind({});
Number.args = {
  type: 'number',
  name: 'numberInput',
  label: 'Number Input',
  state: STATE_MAP.default,
  value: '',
};
Number.parameters = {
  docs: {
    source: {
      code: CodeFactory(Number.args),
    },
  },
};

export const LongLabel = Template.bind({});
LongLabel.args = {
  type: 'text',
  name: 'textInput',
  label: 'This is an input with an extraordinarily long label. Unlikely to ever to exist but oh well',
  state: STATE_MAP.default,
  value: '',
};
LongLabel.parameters = {
  docs: {
    source: {
      code: CodeFactory(LongLabel.args),
    },
  },
};

export const Placeholder = Template.bind({});
Placeholder.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: '',
  placeholder: 'Placeholder defined',
};
Placeholder.parameters = {
  docs: {
    source: {
      code: CodeFactory(Placeholder.args),
    },
  },
};

export const Disabled = Template.bind({});
Disabled.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: '',
  disabled: true,
};
Disabled.parameters = {
  docs: {
    source: {
      code: CodeFactory(Disabled.args),
    },
  },
};

export const Readonly = Template.bind({});
Readonly.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: 'Readonly text',
  readonly: true,
};
Readonly.parameters = {
  docs: {
    source: {
      code: CodeFactory(Readonly.args),
    },
  },
};

export const Error = Template.bind({});
Error.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.error,
  value: '',
};
Error.parameters = {
  docs: {
    source: {
      code: CodeFactory(Error.args),
    },
  },
};

export const Success = Template.bind({});
Success.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.success,
  value: '',
};
Success.parameters = {
  docs: {
    source: {
      code: CodeFactory(Success.args),
    },
  },
};

export const DarkMode = Template.bind({});
DarkMode.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  value: '',
  dark: true,
};
DarkMode.parameters = {
  backgrounds: {
    default: 'Dark Mode',
  },
  docs: {
    source: {
      code: CodeFactory(DarkMode.args),
    },
  },
};

export const Microcopy = Template.bind({});
Microcopy.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: '',
  microcopy: '<IFCSpan>This can be a help message or an error message</IFCSpan>',
};
Microcopy.parameters = {
  docs: {
    source: {
      code: CodeFactory(Microcopy.args),
    },
  },
};

const AutoTemplate = (args, { argTypes }) => ({
  props: Object.keys(argTypes),
  components: { IFCInput, IFCThemeProvider },
  data() {
    return {
      internalValue: args.value,
    };
  },
  methods: {
    onFocus: action('@focus'),
    onBlur: action('@blur'),
    onChange: action('@change'),
    onInput: action('@input'),
  },
  template: `
  <IFCThemeProvider>
    <IFCInput
      @focus="onFocus"
      @blur="onBlur"
      @input="onInput($event); internalValue = $event"
      @change="onChange"
      :value="internalValue"
      v-bind="$props" >
      <template #label>
        {{label}}
      </template>
    </IFCInput>
  </IFCThemeProvider>
  `,
});

export const AutomaticMicrocopy = AutoTemplate.bind({});
AutomaticMicrocopy.args = {
  type: 'text',
  name: 'textInput',
  label: 'Try typing into this',
  state: STATE_MAP.default,
  value: '',
  autocomplete: 'off',
  maxlength: 8,
  minlength: 4,
};
AutomaticMicrocopy.parameters = {
  docs: {
    source: {
      code: CodeFactory(AutomaticMicrocopy.args),
    },
  },
};

const CappedTemplate = (args, { argTypes }) => ({
  props: Object.keys(argTypes),
  components: { IFCInput, IFCButton, IFCThemeProvider },
  data() {
    return {
      internalValue: args.value,
    };
  },
  methods: {
    onFocus: action('@focus'),
    onBlur: action('@blur'),
    onChange: action('@change'),
    onInput: action('@input'),
  },
  template: `
  <IFCThemeProvider>
    <IFCInput
      @focus="onFocus"
      @blur="onBlur"
      @input="onInput($event); internalValue = $event"
      @change="onChange"
      :value="internalValue"
      v-bind="$props" >
      <template #label>
        {{label}}
      </template>
      <template #microcopy>
        {{microcopy}}
      </template>
      <template #endcap>
      <IFCButton variant="primary" endcap>Endcap Button</IFCButton>
      </template>
    </IFCInput>
  </IFCThemeProvider>
  `,
});

export const EndCapContent = CappedTemplate.bind({});
EndCapContent.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: '',
  endcap: `
    <IFCButton variant="primary" endcap>Endcap Button</IFCButton>
  `,
};

EndCapContent.parameters = {
  docs: {
    source: {
      code: CodeFactory(EndCapContent.args),
    },
  },
};

const FrontCappedTemplate = (args, { argTypes }) => ({
  props: Object.keys(argTypes),
  components: { IFCInput, IFCButton, IFCThemeProvider },
  data() {
    return {
      internalValue: args.value,
    };
  },
  methods: {
    onFocus: action('@focus'),
    onBlur: action('@blur'),
    onChange: action('@change'),
    onInput: action('@input'),
  },
  template: `
  <IFCThemeProvider>
    <IFCInput
      @focus="onFocus"
      @blur="onBlur"
      @input="onInput($event); internalValue = $event"
      @change="onChange"
      :value="internalValue"
      v-bind="$props" >
      <template #label>
        {{label}}
      </template>
      <template #microcopy>
        {{microcopy}}
      </template>
      <template #front-endcap>
      <IFCButton variant="primary" endcap>Endcap Button</IFCButton>
      </template>
    </IFCInput>
  </IFCThemeProvider>
  `,
});

export const FrontEndCapContent = FrontCappedTemplate.bind({});
FrontEndCapContent.args = {
  type: 'text',
  name: 'textInput',
  label: 'Text Input',
  state: STATE_MAP.default,
  value: '',
  'front-endcap': '<IFCButton variant="primary" endcap>Endcap Button</IFCButton>',
};
FrontEndCapContent.parameters = {
  docs: {
    source: {
      code: CodeFactory(FrontEndCapContent.args),
    },
  },
};
