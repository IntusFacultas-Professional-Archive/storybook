import e from"vue-styled-components";import{TextTheme as r}from"@IntusFacultas/design-system";function t(e){return(t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function n(e,r){return r||(r=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(r)}}))}function o(e,r){return function(e){if(Array.isArray(e))return e}(e)||function(e,r){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var t=[],n=!0,o=!1,l=void 0;try{for(var i,s=e[Symbol.iterator]();!(n=(i=s.next()).done)&&(t.push(i.value),!r||t.length!==r);n=!0);}catch(e){o=!0,l=e}finally{try{n||null==s.return||s.return()}finally{if(o)throw l}}return t}(e,r)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function l(){var e=n(["\n  padding-left: ","px;\n  border-left-style: solid;\n  border-left-width: 2px;\n  font-size: 14px;\n  cursor: pointer;\n  transition: 0.2s all;\n  max-height: 0px;\n  overflow: hidden;\n  border-color: rgba(0, 0, 0, 0.1);\n  color: ",";\n  ",";\n"]);return l=function(){return e},e}function i(){var e=n(['\n  & * {\n    font-family: "Open Sans Regular", -apple-system, BlinkMacSystemFont,\n      "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif,\n      "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n    -webkit-touch-callout: none; /* iOS Safari */\n    -webkit-user-select: none; /* Safari */\n    -khtml-user-select: none; /* Konqueror HTML */\n    -moz-user-select: none; /* Firefox */\n    -ms-user-select: none; /* Internet Explorer/Edge */\n    user-select: none;\n  }\n  padding-left: 0px;\n  list-style: none;\n']);return i=function(){return e},e}function s(){var e=n(["\n  display: block;\n  max-width: ",";\n"]);return s=function(){return e},e}function a(){var e=n(["\n  color: #ff7200;\n  font-size: 16px;\n  font-weight: bold;\n  cursor: pointer;\n  pointer-events: none;\n"]);return a=function(){return e},e}Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector);var c={padding:{type:Number,default:0},breakpoint:{type:Number,default:576},topOffset:{type:Number,default:100},width:{type:String,default:"auto"},textTheme:{type:Object,default:function(){return r}},flavor:String},f=e.span(a()),d=e("nav",c)(s(),(function(e){return e.width?e.width:"auto"})),u={components:{ContentsTable:e("ul",c)(i()),Item:e("li",c)(l(),(function(e){return 10*e.padding+10}),(function(e){return e.dark?e.textTheme.Dark.color:e.textTheme.Normal.color}),(function(e){return e.flavor&&e.textTheme[e.flavor]?"color "+e.textTheme[e.flavor].color:""})),ContentsContainer:d,Toggler:f},data:function(){return{titles:[],override:!1,scrollToOverride:!1}},props:{width:{type:String,default:"auto"},flavor:{type:String,default:""},queryOverride:{type:String,default:""},offset:{type:Number,default:0}},methods:{toggleOverride:function(){this.override=!this.override;var e=!0,r=!1,t=void 0;try{for(var n,o=this.titles[Symbol.iterator]();!(e=(n=o.next()).done);e=!0){n.value.override=this.override}}catch(e){r=!0,t=e}finally{try{e||null==o.return||o.return()}finally{if(r)throw t}}},delayCollapse:function(e){setTimeout((function(){return e.override=!1}),500)},scrollToEl:function(e){var r=e.getBoundingClientRect().top+window.pageYOffset-this.offset;window.scrollTo({top:r-5,behavior:"smooth"}),this.scrollToOverride=!0;var t=this;setTimeout((function(){setTimeout((function(){t.checkTitles()}),100),t.scrollToOverride=!1}),500),e.focus()},debounce:function(e,r,t){var n;return function(){var o=this,l=arguments,i=function(){n=null,t||e.apply(o,l)},s=t&&!n;clearTimeout(n),n=setTimeout(i,r),s&&e.apply(o,l)}},computeOverride:function(e){return!this.scrollToOverride&&this.override||e.override||e.children.filter((function(e){return e.override})).length>0||e.parents.filter((function(e){return e.override})).length>0},computeScreenVisibility:function(e){return!this.scrollToOverride&&(e.visible||e.children.filter((function(e){return e.visible})).length>0)},computeVisibility:function(e){return 0==e.parents.length||1==e.directParents.length&&1==e.parents.length&&this.computeScreenVisibility(e.directParents[0])||this.computeOverride(e)||this.computeScreenVisibility(e)},margined:function(e){return e.visible},isInView:function(e){var r=e.getBoundingClientRect();return r.top<window.innerHeight&&r.bottom>=0},getPathTo:function(e){if(""!==e.id)return'id("'+e.id+'")';if(e===document.body)return e.tagName;for(var r=0,t=e.parentNode.childNodes,n=0;n<t.length;n++){var o=t[n];if(o===e)return this.getPathTo(e.parentNode)+"/"+e.tagName+"["+(r+1)+"]";1===o.nodeType&&o.tagName===e.tagName&&r++}},checkIfTitle:function(e){return this.queryOverride?e.matches(this.queryOverride):e.matches("h1, h2, h3, h4, h5, h6")},calculateTitleType:function(e){return this.queryOverride?e.getAttribute("data-rank"):parseInt(e.tagName[1])},crawl:function(e){for(var r=this,t=[],n=[e],o=[],l=function(){var e=n.pop(),l=!0,i=!1,s=void 0;try{for(var a,c=Array.from(e.children).filter((function(r){return-1==o.indexOf(r)&&!r.isEqualNode(e)}))[Symbol.iterator]();!(l=(a=c.next()).done);l=!0){var f=a.value;n.push(f)}}catch(e){i=!0,s=e}finally{try{l||null==c.return||c.return()}finally{if(i)throw s}}var d=r.getPathTo(e),u=-1==o.indexOf(d),p=r.checkIfTitle(e);u&&p&&t.push({el:e,id:r.getPathTo(e),titleType:r.calculateTitleType(e),offset:-1,visible:!1,hovered:!1,override:!1}),o.push(r.getPathTo(e))};n.length>0;)l();return t.reverse()},checkTitles:function(){var e=window.pageYOffset;if(0!=this.titles.length){var r=!0,t=!1,n=void 0;try{for(var l,i=this.titles.entries()[Symbol.iterator]();!(r=(l=i.next()).done);r=!0){var s=o(l.value,2),a=s[0],c=s[1];if(c.offset=c.el.getBoundingClientRect().top,c.offset<20+this.offset&&c.offset>0){var f=!0,d=!1,u=void 0;try{for(var p,h=this.titles.filter((function(e){return e.visible}))[Symbol.iterator]();!(f=(p=h.next()).done);f=!0){p.value.visible=!1}}catch(e){d=!0,u=e}finally{try{f||null==h.return||h.return()}finally{if(d)throw u}}c.visible=!0}else c.visible&&c.el.getBoundingClientRect().bottom>=(window.innerHeight||document.documentElement.clientHeight)&&(this.titles[a-1]&&(this.titles[a-1].visible=!0),c.visible=!1)}}catch(e){t=!0,n=e}finally{try{r||null==i.return||i.return()}finally{if(t)throw n}}if(0==e&&window.innerWidth-document.documentElement.clientWidth==0){var m=!0,v=!1,g=void 0;try{for(var b,y=this.titles.filter((function(e){return e.visible}))[Symbol.iterator]();!(m=(b=y.next()).done);m=!0){b.value.visible=!1}}catch(e){v=!0,g=e}finally{try{m||null==y.return||y.return()}finally{if(v)throw g}}this.titles[0].visible=!0}else if(window.innerHeight+e>=document.body.offsetHeight){var w=!0,T=!1,x=void 0;try{for(var S,O=this.titles.filter((function(e){return e.visible}))[Symbol.iterator]();!(w=(S=O.next()).done);w=!0){S.value.visible=!1}}catch(e){T=!0,x=e}finally{try{w||null==O.return||O.return()}finally{if(T)throw x}}this.titles[this.titles.length-1].visible=!0}}},assignChildren:function(){for(var e=this,r=0;r<this.titles.length;r++){var t=this.titles[r];t.children||(t.children=[]),t.parents||(t.parents=[]),t.directParents||(t.directParents=[]);for(var n=r+1;n<this.titles.length;n++){var o=this.titles[n];if(!(o.titleType>t.titleType))break;t.children.push(o),o.parents||(o.parents=[]),o.directParents||(o.directParents=[]),o.parents.push(t)}}var l=!0,i=!1,s=void 0;try{for(var a,c=function(){var r=a.value;1==r.parents.length&&r.directParents.push(r.parents[0]),0==r.parents.length?r.siblings=[]:r.siblings=e.titles.filter((function(e){return e.parents.filter((function(e){return e.id==r.parents[0].id})).length>0&&e.parents.length==r.parents.length&&e.id!=r.id}))},f=this.titles[Symbol.iterator]();!(l=(a=f.next()).done);l=!0)c()}catch(e){i=!0,s=e}finally{try{l||null==f.return||f.return()}finally{if(i)throw s}}}},mounted:function(){this.titles=this.crawl(document.getElementsByTagName("body")[0]),this.assignChildren(),this.checkTitles(),window.addEventListener("scroll",this.checkTitles),function(){function e(){var e=window,r=document;if(!("scrollBehavior"in r.documentElement.style&&!0!==e.__forceSmoothScrollPolyfill__)){var n,o=e.HTMLElement||e.Element,l={scroll:e.scroll||e.scrollTo,scrollBy:e.scrollBy,elementScroll:o.prototype.scroll||a,scrollIntoView:o.prototype.scrollIntoView},i=e.performance&&e.performance.now?e.performance.now.bind(e.performance):Date.now,s=(n=e.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(n)?1:0);e.scroll=e.scrollTo=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?m.call(e,r.body,void 0!==arguments[0].left?~~arguments[0].left:e.scrollX||e.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:e.scrollY||e.pageYOffset):l.scroll.call(e,void 0!==arguments[0].left?arguments[0].left:"object"!==t(arguments[0])?arguments[0]:e.scrollX||e.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:e.scrollY||e.pageYOffset))},e.scrollBy=function(){void 0!==arguments[0]&&(c(arguments[0])?l.scrollBy.call(e,void 0!==arguments[0].left?arguments[0].left:"object"!==t(arguments[0])?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):m.call(e,r.body,~~arguments[0].left+(e.scrollX||e.pageXOffset),~~arguments[0].top+(e.scrollY||e.pageYOffset)))},o.prototype.scroll=o.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==c(arguments[0])){var e=arguments[0].left,r=arguments[0].top;m.call(this,this,void 0===e?this.scrollLeft:~~e,void 0===r?this.scrollTop:~~r)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");l.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!==t(arguments[0])?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},o.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==c(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):l.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},o.prototype.scrollIntoView=function(){if(!0!==c(arguments[0])){var t=p(this),n=t.getBoundingClientRect(),o=this.getBoundingClientRect();t!==r.body?(m.call(this,t,t.scrollLeft+o.left-n.left,t.scrollTop+o.top-n.top),"fixed"!==e.getComputedStyle(t).position&&e.scrollBy({left:n.left,top:n.top,behavior:"smooth"})):e.scrollBy({left:o.left,top:o.top,behavior:"smooth"})}else l.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function a(e,r){this.scrollLeft=e,this.scrollTop=r}function c(e){if(null===e||"object"!==t(e)||void 0===e.behavior||"auto"===e.behavior||"instant"===e.behavior)return!0;if("object"===t(e)&&"smooth"===e.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+e.behavior+" is not a valid value for enumeration ScrollBehavior.")}function f(e,r){return"Y"===r?e.clientHeight+s<e.scrollHeight:"X"===r?e.clientWidth+s<e.scrollWidth:void 0}function d(r,t){var n=e.getComputedStyle(r,null)["overflow"+t];return"auto"===n||"scroll"===n}function u(e){var r=f(e,"Y")&&d(e,"Y"),t=f(e,"X")&&d(e,"X");return r||t}function p(e){for(;e!==r.body&&!1===u(e);)e=e.parentNode||e.host;return e}function h(r){var t,n,o,l,s=(i()-r.startTime)/468;l=s=s>1?1:s,t=.5*(1-Math.cos(Math.PI*l)),n=r.startX+(r.x-r.startX)*t,o=r.startY+(r.y-r.startY)*t,r.method.call(r.scrollable,n,o),n===r.x&&o===r.y||e.requestAnimationFrame(h.bind(e,r))}function m(t,n,o){var s,c,f,d,u=i();t===r.body?(s=e,c=e.scrollX||e.pageXOffset,f=e.scrollY||e.pageYOffset,d=l.scroll):(s=t,c=t.scrollLeft,f=t.scrollTop,d=a),h({scrollable:s,method:d,startTime:u,startX:c,startY:f,x:n,y:o})}}"object"===("undefined"==typeof exports?"undefined":t(exports))&&"undefined"!=typeof module?module.exports={polyfill:e}:e()}()},beforeDestroy:function(){window.removeEventListener("scroll",this.checkTitles)}};const p="undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());let h;const m={};const v=u;var g=function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("contents-container",{attrs:{width:e.width}},[t("contents-table",[t("item",{staticClass:"visible-title table-of-contents-title",attrs:{flavor:e.flavor,tabindex:"0"},on:{click:e.toggleOverride,keyup:[function(r){return!r.type.indexOf("key")&&e._k(r.keyCode,"space",32,r.key,[" ","Spacebar"])?null:e.toggleOverride(r)},function(r){return!r.type.indexOf("key")&&e._k(r.keyCode,"enter",13,r.key,"Enter")?null:e.toggleOverride(r)}]}},[e._v("\n      Table of Contents\n      "),e.override?t("toggler",[e._v("−")]):t("toggler",[e._v("+")])],1),e._v(" "),e._l(e.titles,(function(r){return t("item",{key:r.id,class:{"active-title":r.visible,"margined-title":e.margined(r),"visible-title":e.computeVisibility(r)},attrs:{flavor:r.visible?"MissileOrange":e.flavor,tabindex:e.computeVisibility(r)?0:-1,padding:r.titleType-1},on:{click:function(t){return e.scrollToEl(r.el)},keyup:[function(t){return!t.type.indexOf("key")&&e._k(t.keyCode,"space",32,t.key,[" ","Spacebar"])?null:e.scrollToEl(r.el)},function(t){return!t.type.indexOf("key")&&e._k(t.keyCode,"enter",13,t.key,"Enter")?null:e.scrollToEl(r.el)}]}},[e._v(e._s(r.el.innerText))])}))],2)],1)};g._withStripped=!0;const b=function(e,r,t,n,o,l,i,s,a,c){"boolean"!=typeof i&&(a=s,s=i,i=!1);const f="function"==typeof t?t.options:t;let d;if(e&&e.render&&(f.render=e.render,f.staticRenderFns=e.staticRenderFns,f._compiled=!0,o&&(f.functional=!0)),n&&(f._scopeId=n),l?(d=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,a(e)),e&&e._registeredComponents&&e._registeredComponents.add(l)},f._ssrRegister=d):r&&(d=i?function(e){r.call(this,c(e,this.$root.$options.shadowRoot))}:function(e){r.call(this,s(e))}),d)if(f.functional){const e=f.render;f.render=function(r,t){return d.call(t),e(r,t)}}else{const e=f.beforeCreate;f.beforeCreate=e?[].concat(e,d):[d]}return t}({render:g,staticRenderFns:[]},(function(e){e&&e("data-v-57f7f0c4_0",{source:"\n.visible-title {\r\n  max-height: 100px !important;\r\n  padding-bottom: 2px;\r\n  padding-top: 2px;\n}\n.margined-title {\r\n  border-left-style: solid;\r\n  border-left-width: 3px;\r\n  border-left-color: #ff7200 !important;\n}\n.active-title {\r\n  font-weight: bold;\n}\n.table-of-contents-title {\r\n  font-size: 16px;\n}\r\n",map:{version:3,sources:["C:\\Users\\pedro\\Documents\\Personal Projects\\GitHub\\storybook\\storybook\\src\\components\\TableOfContents\\src\\TableOfContents.vue"],names:[],mappings:";AAk0BA;EACA,4BAAA;EACA,mBAAA;EACA,gBAAA;AACA;AACA;EACA,wBAAA;EACA,sBAAA;EACA,qCAAA;AACA;AACA;EACA,iBAAA;AACA;AACA;EACA,eAAA;AACA",file:"TableOfContents.vue",sourcesContent:['<template>\r\n  <contents-container :width="width">\r\n    <contents-table>\r\n      <item\r\n        :flavor="flavor"\r\n        tabindex="0"\r\n        class="visible-title table-of-contents-title"\r\n        @click="toggleOverride"\r\n        @keyup.space="toggleOverride"\r\n        @keyup.enter="toggleOverride"\r\n      >\r\n        Table of Contents\r\n        <toggler v-if="!override">&#43;</toggler>\r\n        <toggler v-else>&#8722;</toggler>\r\n      </item>\r\n      <item\r\n        :flavor="title.visible ? \'MissileOrange\' : flavor"\r\n        :tabindex="computeVisibility(title) ? 0 : -1"\r\n        v-for="title in titles"\r\n        :key="title.id"\r\n        :padding="title.titleType - 1"\r\n        :class="{\r\n          \'active-title\': title.visible,\r\n          \'margined-title\': margined(title),\r\n          \'visible-title\': computeVisibility(title)\r\n        }"\r\n        @click="scrollToEl(title.el)"\r\n        @keyup.space="scrollToEl(title.el)"\r\n        @keyup.enter="scrollToEl(title.el)"\r\n        >{{ title.el.innerText }}</item\r\n      >\r\n    </contents-table>\r\n  </contents-container>\r\n</template>\r\n\r\n<script>\r\nimport styled from "vue-styled-components";\r\nimport { TextTheme } from "@IntusFacultas/design-system";\r\nif (!Element.prototype.matches) {\r\n  Element.prototype.matches =\r\n    Element.prototype.msMatchesSelector ||\r\n    Element.prototype.webkitMatchesSelector;\r\n}\r\nconst props = {\r\n  padding: {\r\n    type: Number,\r\n    default: 0\r\n  },\r\n  breakpoint: {\r\n    type: Number,\r\n    default: 576\r\n  },\r\n  topOffset: {\r\n    type: Number,\r\n    default: 100\r\n  },\r\n  width: {\r\n    type: String,\r\n    default: "auto"\r\n  },\r\n  textTheme: {\r\n    type: Object,\r\n    default: function() {\r\n      return TextTheme;\r\n    }\r\n  },\r\n  flavor: String\r\n};\r\nconst Toggler = styled.span`\r\n  color: #ff7200;\r\n  font-size: 16px;\r\n  font-weight: bold;\r\n  cursor: pointer;\r\n  pointer-events: none;\r\n`;\r\nconst ContentsContainer = styled("nav", props)`\r\n  display: block;\r\n  max-width: ${props => (props.width ? props.width : "auto")};\r\n`;\r\nconst ContentsTable = styled("ul", props)`\r\n  & * {\r\n    font-family: "Open Sans Regular", -apple-system, BlinkMacSystemFont,\r\n      "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif,\r\n      "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\r\n    -webkit-touch-callout: none; /* iOS Safari */\r\n    -webkit-user-select: none; /* Safari */\r\n    -khtml-user-select: none; /* Konqueror HTML */\r\n    -moz-user-select: none; /* Firefox */\r\n    -ms-user-select: none; /* Internet Explorer/Edge */\r\n    user-select: none;\r\n  }\r\n  padding-left: 0px;\r\n  list-style: none;\r\n`;\r\n\r\nconst Item = styled("li", props)`\r\n  padding-left: ${props => props.padding * 10 + 10}px;\r\n  border-left-style: solid;\r\n  border-left-width: 2px;\r\n  font-size: 14px;\r\n  cursor: pointer;\r\n  transition: 0.2s all;\r\n  max-height: 0px;\r\n  overflow: hidden;\r\n  border-color: rgba(0, 0, 0, 0.1);\r\n  color: ${props =>\r\n    props.dark ? props.textTheme.Dark.color : props.textTheme.Normal.color};\r\n  ${props =>\r\n    props.flavor\r\n      ? props.textTheme[props.flavor]\r\n        ? "color " + props.textTheme[props.flavor].color\r\n        : ""\r\n      : ""};\r\n`;\r\n\r\nexport const TableOfContents = {\r\n  components: { ContentsTable, Item, ContentsContainer, Toggler },\r\n  data() {\r\n    return {\r\n      titles: [],\r\n      override: false,\r\n      scrollToOverride: false\r\n    };\r\n  },\r\n  props: {\r\n    width: {\r\n      type: String,\r\n      default: "auto"\r\n    },\r\n    flavor: {\r\n      type: String,\r\n      default: ""\r\n    },\r\n    queryOverride: {\r\n      type: String,\r\n      default: ""\r\n    },\r\n    offset: {\r\n      type: Number,\r\n      default: 0\r\n    }\r\n  },\r\n  methods: {\r\n    toggleOverride() {\r\n      this.override = !this.override;\r\n      for (let title of this.titles) {\r\n        title.override = this.override;\r\n      }\r\n    },\r\n    delayCollapse(title) {\r\n      setTimeout(() => (title.override = false), 500);\r\n    },\r\n    scrollToEl(el) {\r\n      const y =\r\n        el.getBoundingClientRect().top + window.pageYOffset - this.offset;\r\n      // el.scrollIntoView({ behavior: "smooth", block: "start" });\r\n      let IEHoldOff = 5; // IE is dumb and can\'t appropriately calculate viewport\r\n      window.scrollTo({ top: y - IEHoldOff, behavior: "smooth" });\r\n      this.scrollToOverride = true;\r\n      let self = this;\r\n      setTimeout(function() {\r\n        setTimeout(() => {\r\n          self.checkTitles();\r\n        }, 100);\r\n        self.scrollToOverride = false;\r\n      }, 500);\r\n      el.focus();\r\n    },\r\n    debounce(func, wait, immediate) {\r\n      // pulled from https://davidwalsh.name/javascript-debounce-function\r\n      var timeout;\r\n      return function() {\r\n        var context = this,\r\n          args = arguments;\r\n        var later = function() {\r\n          timeout = null;\r\n          if (!immediate) func.apply(context, args);\r\n        };\r\n        var callNow = immediate && !timeout;\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n        if (callNow) func.apply(context, args);\r\n      };\r\n    },\r\n    computeOverride(title) {\r\n      return (\r\n        (!this.scrollToOverride && this.override) ||\r\n        title.override ||\r\n        title.children.filter(child => child.override).length > 0 ||\r\n        title.parents.filter(parent => parent.override).length > 0\r\n      );\r\n    },\r\n    computeScreenVisibility(title) {\r\n      return (\r\n        !this.scrollToOverride &&\r\n        (title.visible ||\r\n          title.children.filter(child => child.visible).length > 0)\r\n      );\r\n    },\r\n    computeVisibility(title) {\r\n      return (\r\n        title.parents.length == 0 ||\r\n        (title.directParents.length == 1 &&\r\n          title.parents.length == 1 &&\r\n          this.computeScreenVisibility(title.directParents[0])) ||\r\n        this.computeOverride(title) ||\r\n        this.computeScreenVisibility(title)\r\n      );\r\n    },\r\n    margined(title) {\r\n      return title.visible; //|| title.children.filter(child => child.visible).length > 0\r\n    },\r\n    isInView(el) {\r\n      // pulled from https://stackoverflow.com/questions/123999/how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport\r\n      let box = el.getBoundingClientRect();\r\n      return box.top < window.innerHeight && box.bottom >= 0;\r\n    },\r\n    getPathTo(element) {\r\n      // pulled from https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reloaed-to-the-same-place-even-i/2631931#2631931\r\n      if (element.id !== "") return \'id("\' + element.id + \'")\';\r\n      if (element === document.body) return element.tagName;\r\n\r\n      var ix = 0;\r\n      var siblings = element.parentNode.childNodes;\r\n      for (var i = 0; i < siblings.length; i++) {\r\n        var sibling = siblings[i];\r\n        if (sibling === element)\r\n          return (\r\n            this.getPathTo(element.parentNode) +\r\n            "/" +\r\n            element.tagName +\r\n            "[" +\r\n            (ix + 1) +\r\n            "]"\r\n          );\r\n        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;\r\n      }\r\n    },\r\n    checkIfTitle(el) {\r\n      if (this.queryOverride) {\r\n        return el.matches(this.queryOverride);\r\n      } else {\r\n        return el.matches("h1, h2, h3, h4, h5, h6");\r\n      }\r\n    },\r\n    calculateTitleType(el) {\r\n      if (this.queryOverride) {\r\n        return el.getAttribute("data-rank");\r\n      } else {\r\n        return parseInt(el.tagName[1]);\r\n      }\r\n    },\r\n    crawl(node) {\r\n      let titles = [];\r\n      let stack = [node];\r\n      let visited = [];\r\n      while (stack.length > 0) {\r\n        let el = stack.pop();\r\n        for (let child of Array.from(el.children).filter(\r\n          c => visited.indexOf(c) == -1 && !c.isEqualNode(el)\r\n        )) {\r\n          stack.push(child);\r\n        }\r\n        let path = this.getPathTo(el);\r\n        let notVisited = visited.indexOf(path) == -1;\r\n        let isTitle = this.checkIfTitle(el);\r\n        if (notVisited && isTitle) {\r\n          titles.push({\r\n            el: el,\r\n            id: this.getPathTo(el),\r\n            titleType: this.calculateTitleType(el),\r\n            offset: -1,\r\n            visible: false,\r\n            hovered: false,\r\n            override: false\r\n          });\r\n        }\r\n        visited.push(this.getPathTo(el));\r\n      }\r\n      return titles.reverse();\r\n    },\r\n    checkTitles() {\r\n      let yOffset = window.pageYOffset;\r\n      if (this.titles.length == 0) {\r\n        return;\r\n      }\r\n      for (let [index, title] of this.titles.entries()) {\r\n        title.offset = title.el.getBoundingClientRect().top;\r\n        if (title.offset < 20 + this.offset && title.offset > 0) {\r\n          for (let other of this.titles.filter(o => o.visible)) {\r\n            other.visible = false;\r\n          }\r\n          title.visible = true;\r\n        } else if (\r\n          title.visible &&\r\n          title.el.getBoundingClientRect().bottom >=\r\n            (window.innerHeight || document.documentElement.clientHeight)\r\n        ) {\r\n          if (this.titles[index - 1]) this.titles[index - 1].visible = true;\r\n          title.visible = false;\r\n        }\r\n      }\r\n      if (\r\n        yOffset == 0 &&\r\n        window.innerWidth - document.documentElement.clientWidth == 0\r\n      ) {\r\n        for (let other of this.titles.filter(o => o.visible)) {\r\n          other.visible = false;\r\n        }\r\n        this.titles[0].visible = true;\r\n      } else if (window.innerHeight + yOffset >= document.body.offsetHeight) {\r\n        for (let other of this.titles.filter(o => o.visible)) {\r\n          other.visible = false;\r\n        }\r\n        this.titles[this.titles.length - 1].visible = true;\r\n      }\r\n    },\r\n    assignChildren() {\r\n      for (let title = 0; title < this.titles.length; title++) {\r\n        let parentTitle = this.titles[title];\r\n\r\n        // instantiate parents, children, and direct parents arrays\r\n        if (!parentTitle.children) {\r\n          parentTitle.children = [];\r\n        }\r\n        if (!parentTitle.parents) {\r\n          parentTitle.parents = [];\r\n        }\r\n        if (!parentTitle.directParents) {\r\n          parentTitle.directParents = [];\r\n        }\r\n\r\n        for (\r\n          let potentialChild = title + 1;\r\n          potentialChild < this.titles.length;\r\n          potentialChild++\r\n        ) {\r\n          let childTitle = this.titles[potentialChild];\r\n\r\n          // if titletype is greater than parent, title is child of parent\r\n          if (childTitle.titleType > parentTitle.titleType) {\r\n            parentTitle.children.push(childTitle);\r\n            if (!childTitle.parents) {\r\n              childTitle.parents = [];\r\n            }\r\n            if (!childTitle.directParents) {\r\n              childTitle.directParents = [];\r\n            }\r\n\r\n            childTitle.parents.push(parentTitle);\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      for (let title of this.titles) {\r\n        // look for titles with only root level parents\r\n        if (title.parents.length == 1) {\r\n          title.directParents.push(title.parents[0]);\r\n        }\r\n        // assign siblings\r\n        if (title.parents.length == 0) {\r\n          title.siblings = [];\r\n        } else {\r\n          title.siblings = this.titles.filter(\r\n            o =>\r\n              o.parents.filter(p => p.id == title.parents[0].id).length > 0 &&\r\n              o.parents.length == title.parents.length &&\r\n              o.id != title.id\r\n          );\r\n        }\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    this.titles = this.crawl(document.getElementsByTagName("body")[0]);\r\n    this.assignChildren();\r\n    this.checkTitles();\r\n    window.addEventListener("scroll", this.checkTitles);\r\n    (function() {\r\n      "use strict";\r\n\r\n      // polyfill\r\n      function polyfill() {\r\n        // aliases\r\n        var w = window;\r\n        var d = document;\r\n\r\n        // return if scroll behavior is supported and polyfill is not forced\r\n        if (\r\n          "scrollBehavior" in d.documentElement.style &&\r\n          w.__forceSmoothScrollPolyfill__ !== true\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        // globals\r\n        var Element = w.HTMLElement || w.Element;\r\n        var SCROLL_TIME = 468;\r\n\r\n        // object gathering original scroll methods\r\n        var original = {\r\n          scroll: w.scroll || w.scrollTo,\r\n          scrollBy: w.scrollBy,\r\n          elementScroll: Element.prototype.scroll || scrollElement,\r\n          scrollIntoView: Element.prototype.scrollIntoView\r\n        };\r\n\r\n        // define timing method\r\n        var now =\r\n          w.performance && w.performance.now\r\n            ? w.performance.now.bind(w.performance)\r\n            : Date.now;\r\n\r\n        /**\r\n         * indicates if a the current browser is made by Microsoft\r\n         * @method isMicrosoftBrowser\r\n         * @param {String} userAgent\r\n         * @returns {Boolean}\r\n         */\r\n        function isMicrosoftBrowser(userAgent) {\r\n          var userAgentPatterns = ["MSIE ", "Trident/", "Edge/"];\r\n\r\n          return new RegExp(userAgentPatterns.join("|")).test(userAgent);\r\n        }\r\n\r\n        /*\r\n         * IE has rounding bug rounding down clientHeight and clientWidth and\r\n         * rounding up scrollHeight and scrollWidth causing false positives\r\n         * on hasScrollableSpace\r\n         */\r\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent)\r\n          ? 1\r\n          : 0;\r\n\r\n        /**\r\n         * changes scroll position inside an element\r\n         * @method scrollElement\r\n         * @param {Number} x\r\n         * @param {Number} y\r\n         * @returns {undefined}\r\n         */\r\n        function scrollElement(x, y) {\r\n          this.scrollLeft = x;\r\n          this.scrollTop = y;\r\n        }\r\n\r\n        /**\r\n         * returns result of applying ease math function to a number\r\n         * @method ease\r\n         * @param {Number} k\r\n         * @returns {Number}\r\n         */\r\n        function ease(k) {\r\n          return 0.5 * (1 - Math.cos(Math.PI * k));\r\n        }\r\n\r\n        /**\r\n         * indicates if a smooth behavior should be applied\r\n         * @method shouldBailOut\r\n         * @param {Number|Object} firstArg\r\n         * @returns {Boolean}\r\n         */\r\n        function shouldBailOut(firstArg) {\r\n          if (\r\n            firstArg === null ||\r\n            typeof firstArg !== "object" ||\r\n            firstArg.behavior === undefined ||\r\n            firstArg.behavior === "auto" ||\r\n            firstArg.behavior === "instant"\r\n          ) {\r\n            // first argument is not an object/null\r\n            // or behavior is auto, instant or undefined\r\n            return true;\r\n          }\r\n\r\n          if (typeof firstArg === "object" && firstArg.behavior === "smooth") {\r\n            // first argument is an object and behavior is smooth\r\n            return false;\r\n          }\r\n\r\n          // throw error when behavior is not supported\r\n          throw new TypeError(\r\n            "behavior member of ScrollOptions " +\r\n              firstArg.behavior +\r\n              " is not a valid value for enumeration ScrollBehavior."\r\n          );\r\n        }\r\n\r\n        /**\r\n         * indicates if an element has scrollable space in the provided axis\r\n         * @method hasScrollableSpace\r\n         * @param {Node} el\r\n         * @param {String} axis\r\n         * @returns {Boolean}\r\n         */\r\n        function hasScrollableSpace(el, axis) {\r\n          if (axis === "Y") {\r\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\r\n          }\r\n\r\n          if (axis === "X") {\r\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\r\n          }\r\n        }\r\n\r\n        /**\r\n         * indicates if an element has a scrollable overflow property in the axis\r\n         * @method canOverflow\r\n         * @param {Node} el\r\n         * @param {String} axis\r\n         * @returns {Boolean}\r\n         */\r\n        function canOverflow(el, axis) {\r\n          var overflowValue = w.getComputedStyle(el, null)["overflow" + axis];\r\n\r\n          return overflowValue === "auto" || overflowValue === "scroll";\r\n        }\r\n\r\n        /**\r\n         * indicates if an element can be scrolled in either axis\r\n         * @method isScrollable\r\n         * @param {Node} el\r\n         * @param {String} axis\r\n         * @returns {Boolean}\r\n         */\r\n        function isScrollable(el) {\r\n          var isScrollableY =\r\n            hasScrollableSpace(el, "Y") && canOverflow(el, "Y");\r\n          var isScrollableX =\r\n            hasScrollableSpace(el, "X") && canOverflow(el, "X");\r\n\r\n          return isScrollableY || isScrollableX;\r\n        }\r\n\r\n        /**\r\n         * finds scrollable parent of an element\r\n         * @method findScrollableParent\r\n         * @param {Node} el\r\n         * @returns {Node} el\r\n         */\r\n        function findScrollableParent(el) {\r\n          while (el !== d.body && isScrollable(el) === false) {\r\n            el = el.parentNode || el.host;\r\n          }\r\n\r\n          return el;\r\n        }\r\n\r\n        /**\r\n         * self invoked function that, given a context, steps through scrolling\r\n         * @method step\r\n         * @param {Object} context\r\n         * @returns {undefined}\r\n         */\r\n        function step(context) {\r\n          var time = now();\r\n          var value;\r\n          var currentX;\r\n          var currentY;\r\n          var elapsed = (time - context.startTime) / SCROLL_TIME;\r\n\r\n          // avoid elapsed times higher than one\r\n          elapsed = elapsed > 1 ? 1 : elapsed;\r\n\r\n          // apply easing to elapsed time\r\n          value = ease(elapsed);\r\n\r\n          currentX = context.startX + (context.x - context.startX) * value;\r\n          currentY = context.startY + (context.y - context.startY) * value;\r\n\r\n          context.method.call(context.scrollable, currentX, currentY);\r\n\r\n          // scroll more if we have not reached our destination\r\n          if (currentX !== context.x || currentY !== context.y) {\r\n            w.requestAnimationFrame(step.bind(w, context));\r\n          }\r\n        }\r\n\r\n        /**\r\n         * scrolls window or element with a smooth behavior\r\n         * @method smoothScroll\r\n         * @param {Object|Node} el\r\n         * @param {Number} x\r\n         * @param {Number} y\r\n         * @returns {undefined}\r\n         */\r\n        function smoothScroll(el, x, y) {\r\n          var scrollable;\r\n          var startX;\r\n          var startY;\r\n          var method;\r\n          var startTime = now();\r\n\r\n          // define scroll context\r\n          if (el === d.body) {\r\n            scrollable = w;\r\n            startX = w.scrollX || w.pageXOffset;\r\n            startY = w.scrollY || w.pageYOffset;\r\n            method = original.scroll;\r\n          } else {\r\n            scrollable = el;\r\n            startX = el.scrollLeft;\r\n            startY = el.scrollTop;\r\n            method = scrollElement;\r\n          }\r\n\r\n          // scroll looping over a frame\r\n          step({\r\n            scrollable: scrollable,\r\n            method: method,\r\n            startTime: startTime,\r\n            startX: startX,\r\n            startY: startY,\r\n            x: x,\r\n            y: y\r\n          });\r\n        }\r\n\r\n        // ORIGINAL METHODS OVERRIDES\r\n        // w.scroll and w.scrollTo\r\n        w.scroll = w.scrollTo = function() {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            original.scroll.call(\r\n              w,\r\n              arguments[0].left !== undefined\r\n                ? arguments[0].left\r\n                : typeof arguments[0] !== "object"\r\n                ? arguments[0]\r\n                : w.scrollX || w.pageXOffset,\r\n              // use top prop, second argument if present or fallback to scrollY\r\n              arguments[0].top !== undefined\r\n                ? arguments[0].top\r\n                : arguments[1] !== undefined\r\n                ? arguments[1]\r\n                : w.scrollY || w.pageYOffset\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          smoothScroll.call(\r\n            w,\r\n            d.body,\r\n            arguments[0].left !== undefined\r\n              ? ~~arguments[0].left\r\n              : w.scrollX || w.pageXOffset,\r\n            arguments[0].top !== undefined\r\n              ? ~~arguments[0].top\r\n              : w.scrollY || w.pageYOffset\r\n          );\r\n        };\r\n\r\n        // w.scrollBy\r\n        w.scrollBy = function() {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0])) {\r\n            original.scrollBy.call(\r\n              w,\r\n              arguments[0].left !== undefined\r\n                ? arguments[0].left\r\n                : typeof arguments[0] !== "object"\r\n                ? arguments[0]\r\n                : 0,\r\n              arguments[0].top !== undefined\r\n                ? arguments[0].top\r\n                : arguments[1] !== undefined\r\n                ? arguments[1]\r\n                : 0\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          smoothScroll.call(\r\n            w,\r\n            d.body,\r\n            ~~arguments[0].left + (w.scrollX || w.pageXOffset),\r\n            ~~arguments[0].top + (w.scrollY || w.pageYOffset)\r\n          );\r\n        };\r\n\r\n        // Element.prototype.scroll and Element.prototype.scrollTo\r\n        Element.prototype.scroll = Element.prototype.scrollTo = function() {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            // if one number is passed, throw error to match Firefox implementation\r\n            if (\r\n              typeof arguments[0] === "number" &&\r\n              arguments[1] === undefined\r\n            ) {\r\n              throw new SyntaxError("Value could not be converted");\r\n            }\r\n\r\n            original.elementScroll.call(\r\n              this,\r\n              // use left prop, first number argument or fallback to scrollLeft\r\n              arguments[0].left !== undefined\r\n                ? ~~arguments[0].left\r\n                : typeof arguments[0] !== "object"\r\n                ? ~~arguments[0]\r\n                : this.scrollLeft,\r\n              // use top prop, second argument or fallback to scrollTop\r\n              arguments[0].top !== undefined\r\n                ? ~~arguments[0].top\r\n                : arguments[1] !== undefined\r\n                ? ~~arguments[1]\r\n                : this.scrollTop\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          var left = arguments[0].left;\r\n          var top = arguments[0].top;\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          smoothScroll.call(\r\n            this,\r\n            this,\r\n            typeof left === "undefined" ? this.scrollLeft : ~~left,\r\n            typeof top === "undefined" ? this.scrollTop : ~~top\r\n          );\r\n        };\r\n\r\n        // Element.prototype.scrollBy\r\n        Element.prototype.scrollBy = function() {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            original.elementScroll.call(\r\n              this,\r\n              arguments[0].left !== undefined\r\n                ? ~~arguments[0].left + this.scrollLeft\r\n                : ~~arguments[0] + this.scrollLeft,\r\n              arguments[0].top !== undefined\r\n                ? ~~arguments[0].top + this.scrollTop\r\n                : ~~arguments[1] + this.scrollTop\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          this.scroll({\r\n            left: ~~arguments[0].left + this.scrollLeft,\r\n            top: ~~arguments[0].top + this.scrollTop,\r\n            behavior: arguments[0].behavior\r\n          });\r\n        };\r\n\r\n        // Element.prototype.scrollIntoView\r\n        Element.prototype.scrollIntoView = function() {\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            original.scrollIntoView.call(\r\n              this,\r\n              arguments[0] === undefined ? true : arguments[0]\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          var scrollableParent = findScrollableParent(this);\r\n          var parentRects = scrollableParent.getBoundingClientRect();\r\n          var clientRects = this.getBoundingClientRect();\r\n\r\n          if (scrollableParent !== d.body) {\r\n            // reveal element inside parent\r\n            smoothScroll.call(\r\n              this,\r\n              scrollableParent,\r\n              scrollableParent.scrollLeft + clientRects.left - parentRects.left,\r\n              scrollableParent.scrollTop + clientRects.top - parentRects.top\r\n            );\r\n\r\n            // reveal parent in viewport unless is fixed\r\n            if (w.getComputedStyle(scrollableParent).position !== "fixed") {\r\n              w.scrollBy({\r\n                left: parentRects.left,\r\n                top: parentRects.top,\r\n                behavior: "smooth"\r\n              });\r\n            }\r\n          } else {\r\n            // reveal element in viewport\r\n            w.scrollBy({\r\n              left: clientRects.left,\r\n              top: clientRects.top,\r\n              behavior: "smooth"\r\n            });\r\n          }\r\n        };\r\n      }\r\n\r\n      if (typeof exports === "object" && typeof module !== "undefined") {\r\n        // commonjs\r\n        module.exports = { polyfill: polyfill };\r\n      } else {\r\n        // global\r\n        polyfill();\r\n      }\r\n    })();\r\n  },\r\n  beforeDestroy() {\r\n    window.removeEventListener("scroll", this.checkTitles);\r\n  }\r\n};\r\nexport default TableOfContents;\r\n<\/script>\r\n\r\n<style>\r\n.visible-title {\r\n  max-height: 100px !important;\r\n  padding-bottom: 2px;\r\n  padding-top: 2px;\r\n}\r\n.margined-title {\r\n  border-left-style: solid;\r\n  border-left-width: 3px;\r\n  border-left-color: #ff7200 !important;\r\n}\r\n.active-title {\r\n  font-weight: bold;\r\n}\r\n.table-of-contents-title {\r\n  font-size: 16px;\r\n}\r\n</style>\r\n']},media:void 0})}),v,void 0,!1,void 0,!1,(function(e){return(e,r)=>function(e,r){const t=p?r.media||"default":e,n=m[t]||(m[t]={ids:new Set,styles:[]});if(!n.ids.has(e)){n.ids.add(e);let t=r.source;if(r.map&&(t+="\n/*# sourceURL="+r.map.sources[0]+" */",t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r.map))))+" */"),n.element||(n.element=document.createElement("style"),n.element.type="text/css",r.media&&n.element.setAttribute("media",r.media),void 0===h&&(h=document.head||document.getElementsByTagName("head")[0]),h.appendChild(n.element)),"styleSheet"in n.element)n.styles.push(t),n.element.styleSheet.cssText=n.styles.filter(Boolean).join("\n");else{const e=n.ids.size-1,r=document.createTextNode(t),o=n.element.childNodes;o[e]&&n.element.removeChild(o[e]),o.length?n.element.insertBefore(r,o[e]):n.element.appendChild(r)}}}(e,r)}),void 0,void 0);var y=function(e){y.installed||(y.installed=!0,e.component("TableOfContents",b))},w={install:y},T=null;"undefined"!=typeof window?T=window.Vue:"undefined"!=typeof global&&(T=global.Vue),T&&T.use(w),b.install=y;export default b;
