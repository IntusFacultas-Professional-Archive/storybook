{"version":3,"file":"TableOfContents.esm.js","sources":["../src/TableOfContents.vue","../src/entry.js"],"sourcesContent":["<template>\r\n  <contents-container :width=\"width\">\r\n    <contents-table>\r\n      <item\r\n        :flavor=\"flavor\"\r\n        tabindex=\"0\"\r\n        class=\"visible-title table-of-contents-title\"\r\n        @click=\"toggleOverride\"\r\n        @keyup.space=\"toggleOverride\"\r\n        @keyup.enter=\"toggleOverride\"\r\n      >\r\n        Table of Contents\r\n        <toggler v-if=\"!override\">&#43;</toggler>\r\n        <toggler v-else>&#8722;</toggler>\r\n      </item>\r\n      <item\r\n        :flavor=\"title.visible ? 'MissileOrange' : flavor\"\r\n        :tabindex=\"computeVisibility(title) ? 0 : -1\"\r\n        v-for=\"title in titles\"\r\n        :key=\"title.id\"\r\n        :padding=\"title.titleType - 1\"\r\n        :class=\"{\r\n          'active-title': title.visible,\r\n          'margined-title': margined(title),\r\n          'visible-title': computeVisibility(title),\r\n        }\"\r\n        @click=\"scrollToEl(title.el)\"\r\n        @keyup.space=\"scrollToEl(title.el)\"\r\n        @keyup.enter=\"scrollToEl(title.el)\"\r\n        >{{ title.el.innerText }}</item\r\n      >\r\n    </contents-table>\r\n  </contents-container>\r\n</template>\r\n\r\n<script>\r\nimport styled from \"vue-styled-components\";\r\nimport { TextTheme } from \"@IntusFacultas/design-system\";\r\nif (!Element.prototype.matches) {\r\n  Element.prototype.matches =\r\n    Element.prototype.msMatchesSelector ||\r\n    Element.prototype.webkitMatchesSelector;\r\n}\r\n\r\nif (!Array.from) {\r\n  Array.from = (function () {\r\n    var toStr = Object.prototype.toString;\r\n    var isCallable = function (fn) {\r\n      return typeof fn === \"function\" || toStr.call(fn) === \"[object Function]\";\r\n    };\r\n    var toInteger = function (value) {\r\n      var number = Number(value);\r\n      if (isNaN(number)) {\r\n        return 0;\r\n      }\r\n      if (number === 0 || !isFinite(number)) {\r\n        return number;\r\n      }\r\n      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\r\n    };\r\n    var maxSafeInteger = Math.pow(2, 53) - 1;\r\n    var toLength = function (value) {\r\n      var len = toInteger(value);\r\n      return Math.min(Math.max(len, 0), maxSafeInteger);\r\n    };\r\n\r\n    // The length property of the from method is 1.\r\n    return function from(arrayLike /*, mapFn, thisArg */) {\r\n      // 1. Let C be the this value.\r\n      var C = this;\r\n\r\n      // 2. Let items be ToObject(arrayLike).\r\n      var items = Object(arrayLike);\r\n\r\n      // 3. ReturnIfAbrupt(items).\r\n      if (arrayLike == null) {\r\n        throw new TypeError(\r\n          \"Array.from requires an array-like object - not null or undefined\"\r\n        );\r\n      }\r\n\r\n      // 4. If mapfn is undefined, then let mapping be false.\r\n      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\r\n      var T;\r\n      if (typeof mapFn !== \"undefined\") {\r\n        // 5. else\r\n        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\r\n        if (!isCallable(mapFn)) {\r\n          throw new TypeError(\r\n            \"Array.from: when provided, the second argument must be a function\"\r\n          );\r\n        }\r\n\r\n        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\r\n        if (arguments.length > 2) {\r\n          T = arguments[2];\r\n        }\r\n      }\r\n\r\n      // 10. Let lenValue be Get(items, \"length\").\r\n      // 11. Let len be ToLength(lenValue).\r\n      var len = toLength(items.length);\r\n\r\n      // 13. If IsConstructor(C) is true, then\r\n      // 13. a. Let A be the result of calling the [[Construct]] internal method\r\n      // of C with an argument list containing the single item len.\r\n      // 14. a. Else, Let A be ArrayCreate(len).\r\n      var A = isCallable(C) ? Object(new C(len)) : new Array(len);\r\n\r\n      // 16. Let k be 0.\r\n      var k = 0;\r\n      // 17. Repeat, while k < lenâ€¦ (also steps a - h)\r\n      var kValue;\r\n      while (k < len) {\r\n        kValue = items[k];\r\n        if (mapFn) {\r\n          A[k] =\r\n            typeof T === \"undefined\"\r\n              ? mapFn(kValue, k)\r\n              : mapFn.call(T, kValue, k);\r\n        } else {\r\n          A[k] = kValue;\r\n        }\r\n        k += 1;\r\n      }\r\n      // 18. Let putStatus be Put(A, \"length\", len, true).\r\n      A.length = len;\r\n      // 20. Return A.\r\n      return A;\r\n    };\r\n  })();\r\n}\r\n\r\nconst props = {\r\n  padding: {\r\n    type: Number,\r\n    default: 0,\r\n  },\r\n  breakpoint: {\r\n    type: Number,\r\n    default: 576,\r\n  },\r\n  topOffset: {\r\n    type: Number,\r\n    default: 100,\r\n  },\r\n  width: {\r\n    type: String,\r\n    default: \"auto\",\r\n  },\r\n  textTheme: {\r\n    type: Object,\r\n    default: function () {\r\n      return TextTheme;\r\n    },\r\n  },\r\n  flavor: String,\r\n};\r\nconst Toggler = styled.span`\r\n  color: #ff7200;\r\n  font-size: 16px;\r\n  font-weight: bold;\r\n  cursor: pointer;\r\n  pointer-events: none;\r\n`;\r\nconst ContentsContainer = styled(\"nav\", props)`\r\n  display: block;\r\n  max-width: ${(props) => (props.width ? props.width : \"auto\")};\r\n`;\r\nconst ContentsTable = styled(\"ul\", props)`\r\n  & * {\r\n    font-family: \"Open Sans Regular\", -apple-system, BlinkMacSystemFont,\r\n      \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif,\r\n      \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\r\n    -webkit-touch-callout: none; /* iOS Safari */\r\n    -webkit-user-select: none; /* Safari */\r\n    -khtml-user-select: none; /* Konqueror HTML */\r\n    -moz-user-select: none; /* Firefox */\r\n    -ms-user-select: none; /* Internet Explorer/Edge */\r\n    user-select: none;\r\n  }\r\n  padding-left: 0px;\r\n  list-style: none;\r\n`;\r\n\r\nconst Item = styled(\"li\", props)`\r\n  padding-left: ${(props) => props.padding * 10 + 10}px;\r\n  border-left-style: solid;\r\n  border-left-width: 2px;\r\n  font-size: 14px;\r\n  cursor: pointer;\r\n  transition: 0.2s all;\r\n  max-height: 0px;\r\n  overflow: hidden;\r\n  border-color: rgba(0, 0, 0, 0.1);\r\n  color: ${(props) =>\r\n    props.dark ? props.textTheme.Dark.color : props.textTheme.Normal.color};\r\n  ${(props) =>\r\n    props.flavor\r\n      ? props.textTheme[props.flavor]\r\n        ? \"color \" + props.textTheme[props.flavor].color\r\n        : \"\"\r\n      : \"\"};\r\n`;\r\n\r\nexport const TableOfContents = {\r\n  components: { ContentsTable, Item, ContentsContainer, Toggler },\r\n  data() {\r\n    return {\r\n      titles: [],\r\n      override: false,\r\n      scrollToOverride: false,\r\n      observer: null,\r\n    };\r\n  },\r\n  props: {\r\n    width: {\r\n      type: String,\r\n      default: \"auto\",\r\n    },\r\n    enableDomListening: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n    flavor: {\r\n      type: String,\r\n      default: \"\",\r\n    },\r\n    ignoreQuery: {\r\n      type: [String, Array],\r\n      default: \"\",\r\n    },\r\n    queryOverride: {\r\n      type: String,\r\n      default: \"\",\r\n    },\r\n    offset: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n  },\r\n  methods: {\r\n    toggleOverride() {\r\n      this.override = !this.override;\r\n      for (let title of this.titles) {\r\n        title.override = this.override;\r\n      }\r\n    },\r\n    delayCollapse(title) {\r\n      setTimeout(() => (title.override = false), 500);\r\n    },\r\n    scrollToEl(el) {\r\n      const y =\r\n        el.getBoundingClientRect().top + window.pageYOffset - this.offset;\r\n      // el.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\r\n      let IEHoldOff = 5; // IE is dumb and can't appropriately calculate viewport\r\n      window.scrollTo({ top: y - IEHoldOff, behavior: \"smooth\" });\r\n      this.scrollToOverride = true;\r\n      let self = this;\r\n      setTimeout(function () {\r\n        setTimeout(() => {\r\n          self.checkTitles();\r\n        }, 100);\r\n        self.scrollToOverride = false;\r\n      }, 500);\r\n      el.focus();\r\n    },\r\n    debounce(func, wait, immediate) {\r\n      // pulled from https://davidwalsh.name/javascript-debounce-function\r\n      var timeout;\r\n      return function () {\r\n        var context = this,\r\n          args = arguments;\r\n        var later = function () {\r\n          timeout = null;\r\n          if (!immediate) func.apply(context, args);\r\n        };\r\n        var callNow = immediate && !timeout;\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n        if (callNow) func.apply(context, args);\r\n      };\r\n    },\r\n    computeOverride(title) {\r\n      return (\r\n        (!this.scrollToOverride && this.override) ||\r\n        title.override ||\r\n        title.children.filter((child) => child.override).length > 0 ||\r\n        title.parents.filter((parent) => parent.override).length > 0\r\n      );\r\n    },\r\n    computeScreenVisibility(title) {\r\n      return (\r\n        !this.scrollToOverride &&\r\n        (title.visible ||\r\n          title.children.filter((child) => child.visible).length > 0)\r\n      );\r\n    },\r\n    computeVisibility(title) {\r\n      return (\r\n        title.parents.length == 0 ||\r\n        (title.directParents.length == 1 &&\r\n          title.parents.length == 1 &&\r\n          this.computeScreenVisibility(title.directParents[0])) ||\r\n        this.computeOverride(title) ||\r\n        this.computeScreenVisibility(title)\r\n      );\r\n    },\r\n    margined(title) {\r\n      return title.visible; //|| title.children.filter(child => child.visible).length > 0\r\n    },\r\n    isInView(el) {\r\n      // pulled from https://stackoverflow.com/questions/123999/how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport\r\n      let box = el.getBoundingClientRect();\r\n      return box.top < window.innerHeight && box.bottom >= 0;\r\n    },\r\n    getPathTo(element) {\r\n      // pulled from https://stackoverflow.com/questions/2631820/how-do-i-ensure-saved-click-coordinates-can-be-reloaed-to-the-same-place-even-i/2631931#2631931\r\n      if (element.id !== \"\") return 'id(\"' + element.id + '\")';\r\n      if (element === document.body) return element.tagName;\r\n\r\n      var ix = 0;\r\n      var siblings = element.parentNode.childNodes;\r\n      for (var i = 0; i < siblings.length; i++) {\r\n        var sibling = siblings[i];\r\n        if (sibling === element)\r\n          return (\r\n            this.getPathTo(element.parentNode) +\r\n            \"/\" +\r\n            element.tagName +\r\n            \"[\" +\r\n            (ix + 1) +\r\n            \"]\"\r\n          );\r\n        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;\r\n      }\r\n    },\r\n    checkIfTitle(el) {\r\n      let notDisqualified = true;\r\n      if (this.ignoreQuery) {\r\n        if (Array.isArray(this.ignoreQuery)) {\r\n          for (let query of this.ignoreQuery) {\r\n            if (el.matches(query)) {\r\n              notDisqualified = false;\r\n              break;\r\n            }\r\n          }\r\n        } else {\r\n          notDisqualified = !el.matches(this.ignoreQuery);\r\n        }\r\n      }\r\n      if (this.queryOverride) {\r\n        return el.matches(this.queryOverride) && notDisqualified;\r\n      } else {\r\n        return el.matches(\"h1, h2, h3, h4, h5, h6\") && notDisqualified;\r\n      }\r\n    },\r\n    calculateTitleType(el) {\r\n      if (this.queryOverride) {\r\n        return el.getAttribute(\"data-rank\");\r\n      } else {\r\n        return parseInt(el.tagName[1]);\r\n      }\r\n    },\r\n    crawl(node) {\r\n      let titles = [];\r\n      let stack = [node];\r\n      let visited = [];\r\n      while (stack.length > 0) {\r\n        let el = stack.pop();\r\n        if (typeof el.children !== \"undefined\") {\r\n          for (let child of Array.from(el.children).filter(\r\n            (c) => visited.indexOf(c) == -1 && !c.isEqualNode(el)\r\n          )) {\r\n            stack.push(child);\r\n          }\r\n        }\r\n        let path = this.getPathTo(el);\r\n        let notVisited = visited.indexOf(path) == -1;\r\n        let isTitle = this.checkIfTitle(el);\r\n        if (notVisited && isTitle) {\r\n          titles.push({\r\n            el: el,\r\n            id: this.getPathTo(el),\r\n            titleType: this.calculateTitleType(el),\r\n            offset: -1,\r\n            visible: false,\r\n            hovered: false,\r\n            override: false,\r\n          });\r\n        }\r\n        visited.push(this.getPathTo(el));\r\n      }\r\n      return titles.reverse();\r\n    },\r\n    checkTitles() {\r\n      let yOffset = window.pageYOffset;\r\n      if (this.titles.length == 0) {\r\n        return;\r\n      }\r\n      for (let [index, title] of this.titles.entries()) {\r\n        title.offset = title.el.getBoundingClientRect().top;\r\n        if (title.offset < 20 + this.offset && title.offset > 0) {\r\n          for (let other of this.titles.filter((o) => o.visible)) {\r\n            other.visible = false;\r\n          }\r\n          title.visible = true;\r\n        } else if (\r\n          title.visible &&\r\n          title.el.getBoundingClientRect().bottom >=\r\n            (window.innerHeight || document.documentElement.clientHeight)\r\n        ) {\r\n          if (this.titles[index - 1]) this.titles[index - 1].visible = true;\r\n          title.visible = false;\r\n        }\r\n      }\r\n      if (\r\n        yOffset == 0 &&\r\n        window.innerWidth - document.documentElement.clientWidth == 0\r\n      ) {\r\n        for (let other of this.titles.filter((o) => o.visible)) {\r\n          other.visible = false;\r\n        }\r\n        this.titles[0].visible = true;\r\n      } else if (window.innerHeight + yOffset >= document.body.offsetHeight) {\r\n        for (let other of this.titles.filter((o) => o.visible)) {\r\n          other.visible = false;\r\n        }\r\n        this.titles[this.titles.length - 1].visible = true;\r\n      }\r\n    },\r\n    assignChildren() {\r\n      for (let title = 0; title < this.titles.length; title++) {\r\n        let parentTitle = this.titles[title];\r\n\r\n        // instantiate parents, children, and direct parents arrays\r\n        if (!parentTitle.children) {\r\n          parentTitle.children = [];\r\n        }\r\n        if (!parentTitle.parents) {\r\n          parentTitle.parents = [];\r\n        }\r\n        if (!parentTitle.directParents) {\r\n          parentTitle.directParents = [];\r\n        }\r\n\r\n        for (\r\n          let potentialChild = title + 1;\r\n          potentialChild < this.titles.length;\r\n          potentialChild++\r\n        ) {\r\n          let childTitle = this.titles[potentialChild];\r\n\r\n          // if titletype is greater than parent, title is child of parent\r\n          if (childTitle.titleType > parentTitle.titleType) {\r\n            parentTitle.children.push(childTitle);\r\n            if (!childTitle.parents) {\r\n              childTitle.parents = [];\r\n            }\r\n            if (!childTitle.directParents) {\r\n              childTitle.directParents = [];\r\n            }\r\n\r\n            childTitle.parents.push(parentTitle);\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      for (let title of this.titles) {\r\n        // look for titles with only root level parents\r\n        if (title.parents.length == 1) {\r\n          title.directParents.push(title.parents[0]);\r\n        }\r\n        // assign siblings\r\n        if (title.parents.length == 0) {\r\n          title.siblings = [];\r\n        } else {\r\n          title.siblings = this.titles.filter(\r\n            (o) =>\r\n              o.parents.filter((p) => p.id == title.parents[0].id).length > 0 &&\r\n              o.parents.length == title.parents.length &&\r\n              o.id != title.id\r\n          );\r\n        }\r\n      }\r\n    },\r\n    updateTitles() {\r\n      this.titles = this.crawl(document.getElementsByTagName(\"body\")[0]);\r\n      this.assignChildren();\r\n      this.checkTitles();\r\n    },\r\n    updateTitlesOnDOMChange(mutationsList) {\r\n      for (let mutation of mutationsList) {\r\n        if (mutation.type === \"childList\") {\r\n          this.updateTitles();\r\n        }\r\n      }\r\n    },\r\n  },\r\n  beforeDestroy() {\r\n    this.observer.disconnect();\r\n  },\r\n  mounted() {\r\n    let body = document.getElementsByTagName(\"body\")[0];\r\n    if (this.enableDomListening) {\r\n      let config = { attributes: false, childList: true, subtree: false };\r\n      this.observer = new MutationObserver(this.updateTitlesOnDOMChange);\r\n      this.observer.observe(body, config);\r\n    } else {\r\n      (function () {\r\n        if (typeof window.CustomEvent === \"function\") return false;\r\n\r\n        function CustomEvent(event, params) {\r\n          params = params || {\r\n            bubbles: false,\r\n            cancelable: false,\r\n            detail: null,\r\n          };\r\n          var evt = document.createEvent(\"CustomEvent\");\r\n          evt.initCustomEvent(\r\n            event,\r\n            params.bubbles,\r\n            params.cancelable,\r\n            params.detail\r\n          );\r\n          return evt;\r\n        }\r\n\r\n        window.CustomEvent = CustomEvent;\r\n      })();\r\n      window.addEventListener(\r\n        \"IntusFacultas-table-of-contents\",\r\n        this.updateTitles\r\n      );\r\n    }\r\n    this.updateTitles();\r\n    window.addEventListener(\"scroll\", this.checkTitles);\r\n    (function () {\r\n      \"use strict\";\r\n\r\n      // polyfill\r\n      function polyfill() {\r\n        // aliases\r\n        var w = window;\r\n        var d = document;\r\n\r\n        // return if scroll behavior is supported and polyfill is not forced\r\n        if (\r\n          \"scrollBehavior\" in d.documentElement.style &&\r\n          w.__forceSmoothScrollPolyfill__ !== true\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        // globals\r\n        var Element = w.HTMLElement || w.Element;\r\n        var SCROLL_TIME = 468;\r\n\r\n        // object gathering original scroll methods\r\n        var original = {\r\n          scroll: w.scroll || w.scrollTo,\r\n          scrollBy: w.scrollBy,\r\n          elementScroll: Element.prototype.scroll || scrollElement,\r\n          scrollIntoView: Element.prototype.scrollIntoView,\r\n        };\r\n\r\n        // define timing method\r\n        var now =\r\n          w.performance && w.performance.now\r\n            ? w.performance.now.bind(w.performance)\r\n            : Date.now;\r\n\r\n        /**\r\n         * indicates if a the current browser is made by Microsoft\r\n         * @method isMicrosoftBrowser\r\n         * @param {String} userAgent\r\n         * @returns {Boolean}\r\n         */\r\n        function isMicrosoftBrowser(userAgent) {\r\n          var userAgentPatterns = [\"MSIE \", \"Trident/\", \"Edge/\"];\r\n\r\n          return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\r\n        }\r\n\r\n        /*\r\n         * IE has rounding bug rounding down clientHeight and clientWidth and\r\n         * rounding up scrollHeight and scrollWidth causing false positives\r\n         * on hasScrollableSpace\r\n         */\r\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent)\r\n          ? 1\r\n          : 0;\r\n\r\n        /**\r\n         * changes scroll position inside an element\r\n         * @method scrollElement\r\n         * @param {Number} x\r\n         * @param {Number} y\r\n         * @returns {undefined}\r\n         */\r\n        function scrollElement(x, y) {\r\n          this.scrollLeft = x;\r\n          this.scrollTop = y;\r\n        }\r\n\r\n        /**\r\n         * returns result of applying ease math function to a number\r\n         * @method ease\r\n         * @param {Number} k\r\n         * @returns {Number}\r\n         */\r\n        function ease(k) {\r\n          return 0.5 * (1 - Math.cos(Math.PI * k));\r\n        }\r\n\r\n        /**\r\n         * indicates if a smooth behavior should be applied\r\n         * @method shouldBailOut\r\n         * @param {Number|Object} firstArg\r\n         * @returns {Boolean}\r\n         */\r\n        function shouldBailOut(firstArg) {\r\n          if (\r\n            firstArg === null ||\r\n            typeof firstArg !== \"object\" ||\r\n            firstArg.behavior === undefined ||\r\n            firstArg.behavior === \"auto\" ||\r\n            firstArg.behavior === \"instant\"\r\n          ) {\r\n            // first argument is not an object/null\r\n            // or behavior is auto, instant or undefined\r\n            return true;\r\n          }\r\n\r\n          if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\r\n            // first argument is an object and behavior is smooth\r\n            return false;\r\n          }\r\n\r\n          // throw error when behavior is not supported\r\n          throw new TypeError(\r\n            \"behavior member of ScrollOptions \" +\r\n              firstArg.behavior +\r\n              \" is not a valid value for enumeration ScrollBehavior.\"\r\n          );\r\n        }\r\n\r\n        /**\r\n         * indicates if an element has scrollable space in the provided axis\r\n         * @method hasScrollableSpace\r\n         * @param {Node} el\r\n         * @param {String} axis\r\n         * @returns {Boolean}\r\n         */\r\n        function hasScrollableSpace(el, axis) {\r\n          if (axis === \"Y\") {\r\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\r\n          }\r\n\r\n          if (axis === \"X\") {\r\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\r\n          }\r\n        }\r\n\r\n        /**\r\n         * indicates if an element has a scrollable overflow property in the axis\r\n         * @method canOverflow\r\n         * @param {Node} el\r\n         * @param {String} axis\r\n         * @returns {Boolean}\r\n         */\r\n        function canOverflow(el, axis) {\r\n          var overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\r\n\r\n          return overflowValue === \"auto\" || overflowValue === \"scroll\";\r\n        }\r\n\r\n        /**\r\n         * indicates if an element can be scrolled in either axis\r\n         * @method isScrollable\r\n         * @param {Node} el\r\n         * @param {String} axis\r\n         * @returns {Boolean}\r\n         */\r\n        function isScrollable(el) {\r\n          var isScrollableY =\r\n            hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\r\n          var isScrollableX =\r\n            hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\r\n\r\n          return isScrollableY || isScrollableX;\r\n        }\r\n\r\n        /**\r\n         * finds scrollable parent of an element\r\n         * @method findScrollableParent\r\n         * @param {Node} el\r\n         * @returns {Node} el\r\n         */\r\n        function findScrollableParent(el) {\r\n          while (el !== d.body && isScrollable(el) === false) {\r\n            el = el.parentNode || el.host;\r\n          }\r\n\r\n          return el;\r\n        }\r\n\r\n        /**\r\n         * self invoked function that, given a context, steps through scrolling\r\n         * @method step\r\n         * @param {Object} context\r\n         * @returns {undefined}\r\n         */\r\n        function step(context) {\r\n          var time = now();\r\n          var value;\r\n          var currentX;\r\n          var currentY;\r\n          var elapsed = (time - context.startTime) / SCROLL_TIME;\r\n\r\n          // avoid elapsed times higher than one\r\n          elapsed = elapsed > 1 ? 1 : elapsed;\r\n\r\n          // apply easing to elapsed time\r\n          value = ease(elapsed);\r\n\r\n          currentX = context.startX + (context.x - context.startX) * value;\r\n          currentY = context.startY + (context.y - context.startY) * value;\r\n\r\n          context.method.call(context.scrollable, currentX, currentY);\r\n\r\n          // scroll more if we have not reached our destination\r\n          if (currentX !== context.x || currentY !== context.y) {\r\n            w.requestAnimationFrame(step.bind(w, context));\r\n          }\r\n        }\r\n\r\n        /**\r\n         * scrolls window or element with a smooth behavior\r\n         * @method smoothScroll\r\n         * @param {Object|Node} el\r\n         * @param {Number} x\r\n         * @param {Number} y\r\n         * @returns {undefined}\r\n         */\r\n        function smoothScroll(el, x, y) {\r\n          var scrollable;\r\n          var startX;\r\n          var startY;\r\n          var method;\r\n          var startTime = now();\r\n\r\n          // define scroll context\r\n          if (el === d.body) {\r\n            scrollable = w;\r\n            startX = w.scrollX || w.pageXOffset;\r\n            startY = w.scrollY || w.pageYOffset;\r\n            method = original.scroll;\r\n          } else {\r\n            scrollable = el;\r\n            startX = el.scrollLeft;\r\n            startY = el.scrollTop;\r\n            method = scrollElement;\r\n          }\r\n\r\n          // scroll looping over a frame\r\n          step({\r\n            scrollable: scrollable,\r\n            method: method,\r\n            startTime: startTime,\r\n            startX: startX,\r\n            startY: startY,\r\n            x: x,\r\n            y: y,\r\n          });\r\n        }\r\n\r\n        // ORIGINAL METHODS OVERRIDES\r\n        // w.scroll and w.scrollTo\r\n        w.scroll = w.scrollTo = function () {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            original.scroll.call(\r\n              w,\r\n              arguments[0].left !== undefined\r\n                ? arguments[0].left\r\n                : typeof arguments[0] !== \"object\"\r\n                ? arguments[0]\r\n                : w.scrollX || w.pageXOffset,\r\n              // use top prop, second argument if present or fallback to scrollY\r\n              arguments[0].top !== undefined\r\n                ? arguments[0].top\r\n                : arguments[1] !== undefined\r\n                ? arguments[1]\r\n                : w.scrollY || w.pageYOffset\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          smoothScroll.call(\r\n            w,\r\n            d.body,\r\n            arguments[0].left !== undefined\r\n              ? ~~arguments[0].left\r\n              : w.scrollX || w.pageXOffset,\r\n            arguments[0].top !== undefined\r\n              ? ~~arguments[0].top\r\n              : w.scrollY || w.pageYOffset\r\n          );\r\n        };\r\n\r\n        // w.scrollBy\r\n        w.scrollBy = function () {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0])) {\r\n            original.scrollBy.call(\r\n              w,\r\n              arguments[0].left !== undefined\r\n                ? arguments[0].left\r\n                : typeof arguments[0] !== \"object\"\r\n                ? arguments[0]\r\n                : 0,\r\n              arguments[0].top !== undefined\r\n                ? arguments[0].top\r\n                : arguments[1] !== undefined\r\n                ? arguments[1]\r\n                : 0\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          smoothScroll.call(\r\n            w,\r\n            d.body,\r\n            ~~arguments[0].left + (w.scrollX || w.pageXOffset),\r\n            ~~arguments[0].top + (w.scrollY || w.pageYOffset)\r\n          );\r\n        };\r\n\r\n        // Element.prototype.scroll and Element.prototype.scrollTo\r\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            // if one number is passed, throw error to match Firefox implementation\r\n            if (\r\n              typeof arguments[0] === \"number\" &&\r\n              arguments[1] === undefined\r\n            ) {\r\n              throw new SyntaxError(\"Value could not be converted\");\r\n            }\r\n\r\n            original.elementScroll.call(\r\n              this,\r\n              // use left prop, first number argument or fallback to scrollLeft\r\n              arguments[0].left !== undefined\r\n                ? ~~arguments[0].left\r\n                : typeof arguments[0] !== \"object\"\r\n                ? ~~arguments[0]\r\n                : this.scrollLeft,\r\n              // use top prop, second argument or fallback to scrollTop\r\n              arguments[0].top !== undefined\r\n                ? ~~arguments[0].top\r\n                : arguments[1] !== undefined\r\n                ? ~~arguments[1]\r\n                : this.scrollTop\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          var left = arguments[0].left;\r\n          var top = arguments[0].top;\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          smoothScroll.call(\r\n            this,\r\n            this,\r\n            typeof left === \"undefined\" ? this.scrollLeft : ~~left,\r\n            typeof top === \"undefined\" ? this.scrollTop : ~~top\r\n          );\r\n        };\r\n\r\n        // Element.prototype.scrollBy\r\n        Element.prototype.scrollBy = function () {\r\n          // avoid action when no arguments are passed\r\n          if (arguments[0] === undefined) {\r\n            return;\r\n          }\r\n\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            original.elementScroll.call(\r\n              this,\r\n              arguments[0].left !== undefined\r\n                ? ~~arguments[0].left + this.scrollLeft\r\n                : ~~arguments[0] + this.scrollLeft,\r\n              arguments[0].top !== undefined\r\n                ? ~~arguments[0].top + this.scrollTop\r\n                : ~~arguments[1] + this.scrollTop\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          this.scroll({\r\n            left: ~~arguments[0].left + this.scrollLeft,\r\n            top: ~~arguments[0].top + this.scrollTop,\r\n            behavior: arguments[0].behavior,\r\n          });\r\n        };\r\n\r\n        // Element.prototype.scrollIntoView\r\n        Element.prototype.scrollIntoView = function () {\r\n          // avoid smooth behavior if not required\r\n          if (shouldBailOut(arguments[0]) === true) {\r\n            original.scrollIntoView.call(\r\n              this,\r\n              arguments[0] === undefined ? true : arguments[0]\r\n            );\r\n\r\n            return;\r\n          }\r\n\r\n          // LET THE SMOOTHNESS BEGIN!\r\n          var scrollableParent = findScrollableParent(this);\r\n          var parentRects = scrollableParent.getBoundingClientRect();\r\n          var clientRects = this.getBoundingClientRect();\r\n\r\n          if (scrollableParent !== d.body) {\r\n            // reveal element inside parent\r\n            smoothScroll.call(\r\n              this,\r\n              scrollableParent,\r\n              scrollableParent.scrollLeft + clientRects.left - parentRects.left,\r\n              scrollableParent.scrollTop + clientRects.top - parentRects.top\r\n            );\r\n\r\n            // reveal parent in viewport unless is fixed\r\n            if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\r\n              w.scrollBy({\r\n                left: parentRects.left,\r\n                top: parentRects.top,\r\n                behavior: \"smooth\",\r\n              });\r\n            }\r\n          } else {\r\n            // reveal element in viewport\r\n            w.scrollBy({\r\n              left: clientRects.left,\r\n              top: clientRects.top,\r\n              behavior: \"smooth\",\r\n            });\r\n          }\r\n        };\r\n      }\r\n\r\n      if (typeof exports === \"object\" && typeof module !== \"undefined\") {\r\n        // commonjs\r\n        module.exports = { polyfill: polyfill };\r\n      } else {\r\n        // global\r\n        polyfill();\r\n      }\r\n    })();\r\n  },\r\n  beforeDestroy() {\r\n    if (!this.enableDomListening) {\r\n      window.removeEventListener(\r\n        \"IntusFacultas-table-of-contents\",\r\n        this.updateTitles\r\n      );\r\n    }\r\n    window.removeEventListener(\"scroll\", this.checkTitles);\r\n  },\r\n};\r\nexport default TableOfContents;\r\n</script>\r\n\r\n<style>\r\n.visible-title {\r\n  max-height: 100px !important;\r\n  padding-bottom: 2px;\r\n  padding-top: 2px;\r\n}\r\n.margined-title {\r\n  border-left-style: solid;\r\n  border-left-width: 3px;\r\n  border-left-color: #ff7200 !important;\r\n}\r\n.active-title {\r\n  font-weight: bold;\r\n}\r\n.table-of-contents-title {\r\n  font-size: 16px;\r\n}\r\n</style>\r\n","// Import vue component\r\nimport TableOfContents from \"./TableOfContents.vue\";\r\n\r\n// install function executed by Vue.use()\r\nconst install = function installTableOfContents(Vue) {\r\n  if (install.installed) return;\r\n  install.installed = true;\r\n  Vue.component(\"TableOfContents\", TableOfContents);\r\n};\r\n\r\n// Create module definition for Vue.use()\r\nconst plugin = {\r\n  install,\r\n};\r\n\r\n// To auto-install when vue is found\r\n// eslint-disable-next-line no-redeclare\r\n/* global window, global */\r\nlet GlobalVue = null;\r\nif (typeof window !== \"undefined\") {\r\n  GlobalVue = window.Vue;\r\n} else if (typeof global !== \"undefined\") {\r\n  GlobalVue = global.Vue;\r\n}\r\nif (GlobalVue) {\r\n  GlobalVue.use(plugin);\r\n}\r\n\r\n// Inject install function into component - allows component\r\n// to be registered via Vue.use() as well as Vue.component()\r\nTableOfContents.install = install;\r\n\r\n// Export component by default\r\nexport default TableOfContents;\r\nexport { TableOfContents };\r\n// It's possible to expose named exports when writing components that can\r\n// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';\r\n// export const RollupDemoDirective = component;\r\n"],"names":["install","installTableOfContents","Vue","installed","component","TableOfContents","plugin","GlobalVue","window","global","use"],"mappings":"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"}